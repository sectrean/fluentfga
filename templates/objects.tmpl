{{- /*gotype: github.com/johnrutherford/fluentfga.Model*/ -}}

{{ define "objects" }}
{{ template "_header" . }}

type Object interface {
    typeName() string
    id() string
    String() string
}

type Userset interface {
    Object
    Relation
}

{{ range .Types }}
// {{ .Type }} represents an object of the "{{ .Name }}" type.
type {{ .Type }} struct {
    {{ .IDName }} {{ .IDType }}
}

func ({{ .Type }}) typeName() string { return "{{ .Name }}" }
func ({{ abbr .Type }} {{ .Type }}) id() string { return fmt.Sprint({{ abbr .Type }}.{{ .IDName }}) }
func ({{ abbr .Type }} {{ .Type }}) String() string { return fmt.Sprint("{{ .Name }}:", {{ abbr .Type }}.{{ .IDName }}) }

{{ if .HasWildcard }}
{{ $wildcardType := print .Type "Wildcard" }}
// {{ $wildcardType }} represents public access: "{{ .Name }}:*".
type {{ $wildcardType }} struct{}

func ({{ $wildcardType }}) typeName() string { return "{{ .Name }}" }
func ({{ $wildcardType }}) id() string { return "*" }
func ({{ $wildcardType }}) String() string { return "{{ .Name }}:*" }

{{ end }}

{{ range .Usersets }}
{{ $usersetType := print .Type }}
// {{ $usersetType }} is the "{{ .Object.Name }}:{{ print "{" .Object.IDName "}" }}#{{ .Relation }}" userset.
type {{ $usersetType }} struct {
    {{ .Object.Type }}
}

func ({{ $usersetType }}) relation() string { return "{{ .Relation }}" }
func (u {{ $usersetType }}) String() string { return fmt.Sprint("{{ .Object.Name }}:", u.id(), "#{{ .Relation }}") }

// {{ .Object.Type }}Userset returns the "{{ .Object.Name }}:{{ print "{" .Object.IDName "}" }}#{{ .Relation }}" userset.
func ({{ abbr .Object.Type }} {{ .Object.Type }}) {{ titleCase .Relation }}Userset() {{ $usersetType }} {
    return {{ $usersetType }}{ {{ abbr .Object.Type }} }
}

{{ end }}

{{ end }}

func newObjects[O Object](objs []string) ([]O, error) {
    objects := make([]O, len(objs))

    // TODO: Use multierror to collect all errors.
    for i, s := range objs {
        parts := strings.Split(s, ":")
        if len(parts) != 2 {
            return nil, fmt.Errorf("invalid object: %q", s)
        }

        obj := newObject(parts[0], parts[1])
        o, ok := obj.(O)
        if !ok {
            return nil, fmt.Errorf("unexpected object type: %q", s)
        }

        objects[i] = o
    }
    return objects, nil
}

func newObject(typ, id string) Object {
    switch typ {
{{- range .Types }}
    case "{{ .Name }}":
        return {{ .Type }}{ {{ .IDName }}: id }
{{- end }}

    default:
        return unknownObject{typ, id}
    }
}

func newUsers(data []sdk.User) []Object {
    users := make([]Object, len(data))

    for i, u := range data {
        users[i] = newUser(u)
    }
    return users
}

func newUser(u sdk.User) Object {
    if u.Object != nil {
        return newObject(u.Object.Type, u.Object.Id)
    }
    if u.Userset != nil {
        return newUserset(u.Userset.Type, u.Userset.Id, u.Userset.Relation)
    }
    if u.Wildcard != nil {
        return newObject(u.Wildcard.Type, "*")
    }

    panic("unknown user type")
}

func newUserset(typ, id, rel string) Userset {
{{- range .Types }}
{{- range .Usersets }}
    if typ == "{{ .Object.Name }}" && rel == "{{ .Relation }}" {
        return {{ .Type }}{ {{ .Object.Type }} { {{ .Object.IDName }}: id } }
    }
{{- end }}
{{- end }}

    panic("unknown userset type")
}

// unknownObject represents an object of an unknown type.
//
// If the authorization model version used by OpenFGA is different from the one this code was generated for,
// it's possible that the server will return objects that are not known to this code.
type unknownObject struct {
    objType, objID string
}

func (o unknownObject) typeName() string { return o.objType }
func (o unknownObject) id() string { return o.objID }
func (o unknownObject) String() string { return fmt.Sprint(o.objType, ":", o.objID) }
{{ end }}
